[{"content":"","date":"2025-03-20T11:43:59+08:00","permalink":"http://localhost:1313/post/note1/","title":"FPS 开发日志 第一篇"},{"content":"Event Bus OnClick -\u0026gt; Event -\u0026gt; Event Bus -\u0026gt; Event -\u0026gt; Subscribers\n","date":"2025-03-19T14:57:11+08:00","permalink":"http://localhost:1313/post/ui/","title":"UI 框架初探索"},{"content":"Interactor Select Action Trigger Name Description State Unity将考虑在按下按钮时激活输入。用户可以在交互成为可能之前保持按钮，并且仍然在交互成为可能时触发交互。（一只手交互时，另一只手不能获取交互物） StateChange Unity将考虑仅在按下按钮的框架上激活输入，如果成功，则保持接合，直到释放输入。当交互可能触发交互时，用户必须按下按钮。如果他们在交互成为可能之前开始按下按钮，他们将不会触发交互。（一只手交互时，另一只手可以获取物品交互权） Sticky 交互在输入被按压的帧上开始，并且保持接合直到输入被第二次释放。 Toggle 交互在输入被按压的帧上开始，并且保持接合直到输入被第二次按压。 创建物体在交互时的反馈 在 XR Interaction Toolkit 版本 \u0026gt;2.3 之后，提供了 XR Interactable Affordance State Provider 组件，以及一些预设好的 Affordance 组件用于创建效果\nXR Interactable Affordance State Provider 在安装了 Starter Assets 资源后，会提供一个 Interaction Affordance 预制体，并默认附带了一个 Color Affordance 物体\n在 Interaction Affordance 预制体中，会默认附带一个 XR Interactable Affordance State Provider 组件，该组件会配合 Affordance 组件反馈物体的交互状态\nInteraction Affordance 将 Interaction Affordance 预制体作为需要反馈交互状态的物体的子物体，在 Interactable Source 绑定需要被监听交互状态的物体即可\nColor Affordance Color Affordance 该组件一般作为 Interaction Affordance 的子物体，在 Affordance State Provider 中绑定反馈交互状态的 XR Interactable Affordance State Provider 组件\n并在 Affordance Theme Datum 中选择反馈的颜色样式，颜色样式可以在 Assets 资源文件夹中 Create/Affordance Theme/Color Affordance Theme 创建\n该组件创建后会附带 Material Property Block Helper 组件，在 Render 处绑定要改变颜色的模型\nAudio Affordance ","date":"2025-03-15T22:44:32+08:00","permalink":"http://localhost:1313/post/xr-interactiontoolkit/","title":"Unity XR Interaction 笔记"},{"content":"安装 DOCFX 从 dotnet tool 安装（推荐） 在 cmd 键入 dotnet tool install -g docfx\n等待安装完成\u0026hellip;\n键入 docfx -v ，没有报错则安装完成\n从 Github 下载最新构建手动安装 在 Github 下载 https://github.com/dotnet/docfx/releases\n将压缩包解压到自己的文件夹中，示例 e:/tools/docfx\n将 docfx 添加到用户变量中\n打开 cmd 输入 docfx -v\n没有报错则安装成功\n为 md 文件自动创建 toc.yml 文件 使用 dotnet tool 安装 DocFxTocGenerator\n在 cmd 键入 dotnet tool install DocFxTocGenerator -g ，等待安装完成\u0026hellip;\n在 cmd 中进入 dcfx 项目的根目录，运行以下命令\n1DocFxTocGenerator -d \u0026lt;md文件夹\u0026gt; 默认创建 toc.yml 会在该 md 文件夹下\n此时文件结构应为\n1- docfx_project 2 - md文件夹 3 - **.md 4 - toc.yml ","date":"2025-03-15T16:00:19+08:00","permalink":"http://localhost:1313/post/api-documentation/","title":"使用 DOCFX 创建 C# API 文档"},{"content":"总字数统计 “发表了x篇文章，共计x字” 在 layouts/partials/footer/footer.html 文件中添加以下代码\n参考 第三夏尔-添加总字数统计\n1\u0026lt;!-- Add total page and word count time --\u0026gt; 2\u0026lt;section class=\u0026#34;totalcount\u0026#34;\u0026gt; 3 {{$scratch := newScratch}} 4 {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} 5 {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} 6 {{ end }} 7 发表了{{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }}篇文章 · 8 总计{{ div ($scratch.Get \u0026#34;total\u0026#34;) 1000.0 | lang.FormatNumber 2 }}k字 9\u0026lt;/section\u0026gt; 在assets/scss/partials/footer.scss里修改风格:\n1.totalcount { 2 color: var(--card-text-color-secondary); 3 font-weight: normal; 4 margin-bottom: 5px; 5 } 修改目录滚动条样式 当文章的目录太长时便会产生滚动条，默认的滚动条样式比较丑陋，所以可以修改成如下样式\n1{ 2 ::-webkit-scrollbar { 3 width: 20px; 4 } 5 6 ::-webkit-scrollbar-track { 7 background-color: transparent; 8 } 9 10 ::-webkit-scrollbar-thumb { 11 background-color: #d6dee1; 12 border-radius: 20px; 13 border: 6px solid transparent; 14 background-clip: content-box; 15 } 16 17 ::-webkit-scrollbar-thumb:hover { 18 background-color: #a8bbbf; 19 } 20} 支持数学公式编辑 使文章能够支持数学公式的编辑\n我们需要在主题根目录的 /layouts/partials 创建 math.html 文件，之后在这个文件中加入如下代码\n1{{ if or .Params.math .Site.Params.math }} 2{{ partial \u0026#34;math.html\u0026#34; . }} 3{{ end }} 4 5\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 6\u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 7\u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; 8 onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这段代码能够自动渲染数学公式，当然这样还是不够的，我们还需要在每篇文章的 markdown 的 header 加上 math=\u0026quot;true\u0026quot; 的选择字段。\n代码块相关 自定义代码字体 参考 某菜鸡的垃圾站\n在站点文件夹（注意不是主题文件夹）下新建 layouts/partials/head/custom.html\n1\u0026lt;style\u0026gt; 2 /* Overwrite CSS variable */ 3 :root { 4 --code-font-family: \u0026#34;JetBrains Mono\u0026#34;; /* 按需修改 */ 5 } 6 7 code { 8 font-size: 1.4rem; /* font size */ 9 } 10 11 pre { 12 font-size: 1.4rem; /* font size */ 13 } 14\u0026lt;/style\u0026gt; 15 16\u0026lt;script\u0026gt; 17 (function () { 18 const customFont = document.createElement(\u0026#39;link\u0026#39;); 19 customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=JetBrains Mono:wght@300;700\u0026amp;display=swap\u0026#34;; /* 按需修改 */ 20 21 customFont.type = \u0026#34;text/css\u0026#34;; 22 customFont.rel = \u0026#34;stylesheet\u0026#34;; 23 24 document.head.appendChild(customFont); 25 }()); 26\u0026lt;/script\u0026gt; 代码块固定高度 参考 Naive Koala\n过长的内容影响观感，所以把 block 的高度限制在 35em，并隐藏滚动条\n在 /assets/scss/partials/layout/article.scss 中进行如下修改（已隐藏无关片段）\n1.article-content { // line 205 2 .highlight { // line 331 3 background-color: var(--pre-background-color); 4- padding: var(--card-padding); 5 position: relative; 6 pre { // line 345 7 margin: initial; 8 padding: 0; 9 margin: 0; 10 width: auto; 11+ max-height: 35em; 12+ scrollbar-width: none; /* Firefox */ 13+ \u0026amp;::-webkit-scrollbar { 14+ display: none; /* Chrome Safari */ 15+ } 16 } 17 } 18} 关于 Dark Reader 参考 某菜鸡的垃圾站\n该主题的暗色模式无法被dark reader检测到\n在在文件 layouts/partials/head/head.html 里 viewport 下面加了一句 \u0026lt;meta name=\u0026quot;color-scheme\u0026quot; content=\u0026quot;dark\u0026quot;\u0026gt;\n使图床链接的图片居中 参考 Naive Koala\n目前 Stack 默认只支持本地引用的图片居中，而在使用 url 图片链接时没有居中格式\n在 /assets/scss/partials/layout/article.scss Line 256 处（同级任意位置）增加以下代码\n1// Center image from url source 2p \u0026gt; img { 3 display: block; 4 margin: 0 auto; 5 max-width: 100%; 6 height: auto; 7} 头像旋转 参考 Naive Koala\n在 /assets/scss/custom.scss 中加入以下代码\n1// 头像旋转动画 2.sidebar header .site-avatar .site-logo { 3 transition: transform 1.65s ease-in-out; // 旋转时间 4} 5 6.sidebar header .site-avatar .site-logo:hover { 7 transform: rotate(360deg); // 旋转角度为360度 8} 修改正文占比 参考 Naive Koala\n在 /assets/scss/grid.scss 中修改 left-sidebar 和 right-sidebar 的描述\n1 .left-sidebar { 2 order: -3; 3 // max-width: var(--left-sidebar-max-width); 4 max-width: 10%; 5 } 6 7 .right-sidebar { 8 order: -1; 9 // max-width: var(--right-sidebar-max-width); 10 max-width: 22%; 11 12 /// Display right sidebar when min-width: lg 13 @include respond(lg) { 14 display: flex; 15 } 16 } 首页欢迎横幅 参考 Naive Koala\n在 /layouts/index.html 的 \u0026lt;section class=\u0026quot;article-list\u0026quot;\u0026gt; 前添加以下代码\n1\u0026lt;!-- 首页欢迎字幅 --\u0026gt; 2\u0026lt;div class=\u0026#34;welcome\u0026#34;\u0026gt; 3 \u0026lt;p style=\u0026#34;font-size: 2rem; text-align: center; font-weight: bold\u0026#34;\u0026gt; 4 \u0026lt;span class=\u0026#34;shake\u0026#34;\u0026gt;👋\u0026lt;/span\u0026gt; 5 \u0026lt;span class=\u0026#34;jump-text1\u0026#34; \u0026gt; Welcome\u0026lt;/span\u0026gt; 6 \u0026lt;span class=\u0026#34;jump-text2\u0026#34;\u0026gt; To \u0026lt;/span\u0026gt; 7 \u0026lt;span class=\u0026#34;jump-text3\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Xa\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text4\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;l\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text5\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text6\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;o\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text7\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;k\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text8\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;\u0026#39;s\u0026lt;/span\u0026gt; 8 \u0026lt;span class=\u0026#34;jump-text9\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Blog\u0026lt;/span\u0026gt; 9 \u0026lt;/p\u0026gt; 10\u0026lt;/div\u0026gt; 11\u0026lt;!-- 首页欢迎字幅 --\u0026gt; 在 /assets/scss/custom.scss 中加入以下代码\n1//首页欢迎板块样式 2.welcome { 3 color: var(--card-text-color-main); 4 background: var(--card-background); 5 box-shadow: var(--shadow-l2); 6 border-radius: 30px; 7 display: inline-block; 8} 9 10// 👋emoji实现摆动效果 11.shake { 12 display: inline-block; 13 animation: shake 1s; 14 animation-duration: 1s; 15 animation-timing-function: ease; 16 animation-delay: 0s; 17 animation-iteration-count: 1; 18 animation-direction: normal; 19 animation-fill-mode: none; 20 animation-play-state: running; 21 animation-name: shake; 22 animation-timeline: auto; 23 animation-range-start: normal; 24 animation-range-end: normal; 25 animation-delay: 2s; 26 @keyframes shake { 27 0% { 28 transform: rotate(0); 29 } 30 25% { 31 transform: rotate(45deg) scale(1.2); 32 } 33 50% { 34 transform: rotate(0) scale(1.2); 35 } 36 75% { 37 transform: rotate(45deg) scale(1.2); 38 } 39 100% { 40 transform: rotate(0); 41 } 42 } 43} 44// 实现字符跳动动画 45.jump-text1 { 46 display: inline-block; 47 animation: jump 0.5s 1; 48} 49 50.jump-text2 { 51 display: inline-block; 52 animation: jump 0.5s 1; 53 animation-delay: 0.1s; 54} 55 56.jump-text3 { 57 display: inline-block; 58 animation: jump 0.5s 1; 59 animation-delay: 0.2s; 60} 61 62.jump-text4 { 63 display: inline-block; 64 animation: jump 0.5s 1; 65 animation-delay: 0.3s; 66} 67 68.jump-text5 { 69 display: inline-block; 70 animation: jump 0.5s 1; 71 animation-delay: 0.4s; 72} 73 74.jump-text6 { 75 display: inline-block; 76 animation: jump 0.5s 1; 77 animation-delay: 0.5s; 78} 79 80.jump-text7 { 81 display: inline-block; 82 animation: jump 0.5s 1; 83 animation-delay: 0.6s; 84} 85 86.jump-text8 { 87 display: inline-block; 88 animation: jump 0.5s 1; 89 animation-delay: 0.7s; 90} 91 92.jump-text9 { 93 display: inline-block; 94 animation: jump 0.5s 1; 95 animation-delay: 0.9s; 96} 97 98@keyframes jump { 99 0% { 100 transform: translateY(0); 101 } 102 50% { 103 transform: translateY(-20px); 104 } 105 100% { 106 transform: translateY(0); 107 } 108} 使用 GitAction 部署时 将 git 时间作为文件更新时间 参考 serenNan\n修改 /.github/workflows/deploy.yml\n1jobs: 2 build-deploy: 3 runs-on: ubuntu-latest 4 # runs-on: macos-latest 5 steps: 6 - name: Check out source 7 uses: actions/checkout@v4 8 9 - name: Git Configuration 10 run: | 11 git config --global core.quotePath false 12 git config --global core.autocrlf false 13 git config --global core.safecrlf true 14 git config --global core.ignorecase false 15 16 - name: Setup hugo 17 uses: peaceiris/actions-hugo@v3 18 with: 19 hugo-version: \u0026#34;0.145.0\u0026#34; # \u0026#34;latest\u0026#34; 可以修改为你使用的 Hugo 版本 20 extended: true # 设置是否需要 extended 版本 修改 hugo.yaml\n1# 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 2frontmatter: 3 lastmod: [\u0026#34;:git\u0026#34;,\u0026#34;:fileModTime\u0026#34;] 4 5enableGitInfo: true # 允许获取Git信息 在主页文章卡片显示创建时间和阅读时长 在 layouts/partials/article/components/details.html 添加\n1 \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; 2 \u0026lt;!-- 创建最后更新时间 --\u0026gt; 3 {{ if and $showDate (ne .Lastmod .Date) }} 4 \u0026lt;span class=\u0026#34;time-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; 5 {{ end }} 6 7 {{- if ne .Lastmod .Date -}} 8 \u0026lt;div class=\u0026#34;article-time--lastmod\u0026#34;\u0026gt; 9 {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} 10 \u0026lt;time\u0026gt; 11 {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} 12 \u0026lt;/time\u0026gt; 13 \u0026lt;/div\u0026gt; 14 {{- end -}} 添加评论功能 giscus 参考 serenNan\n参考 意琦行\n添加行号后复制代码会复制行号的问题 参考 B1ain\u0026rsquo;s Blog\n1.首先解决手动选中内容复制带行号的问题\n在 assets/scss/custom.scss 文件中添加如下内容，将行号设定为不可选中\n1\t// 禁止复制行号 2 .highlight .ln { 3 user-select: none; 4 } 2.解决copy按钮复制带行号的问题\n修改 themes/hugo-theme-stack/assets/ts/main.ts 文件中的复制按钮逻辑\n1 highlights.forEach(highlight =\u0026gt; { 2 const copyButton = document.createElement(\u0026#39;button\u0026#39;); 3 copyButton.innerHTML = copyText; 4 copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); 5 highlight.appendChild(copyButton); 6 7 const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); 8 if (!codeBlock) return; 9 10 copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 11 // 创建一个临时容器来克隆代码块的内容 12 const tempCodeBlock = codeBlock.cloneNode(true) as HTMLElement; 13 14 // 删除行号，行号的元素是 \u0026lt;span class=\u0026#34;ln\u0026#34;\u0026gt; 15 const lineNumbers = tempCodeBlock.querySelectorAll(\u0026#39;.ln\u0026#39;); 16 lineNumbers.forEach(lineNumber =\u0026gt; lineNumber.remove()); 17 18 // 获取没有行号的纯文本内容 19 const codeText = tempCodeBlock.textContent; 20 21 navigator.clipboard.writeText(codeText || \u0026#39;\u0026#39;) 22 // navigator.clipboard.writeText(codeBlock.textContent) 23 .then(() =\u0026gt; { 24 copyButton.textContent = copiedText; 25 26 setTimeout(() =\u0026gt; { 27 copyButton.textContent = copyText; 28 }, 1000); 29 }) 30 .catch(err =\u0026gt; { 31 alert(err) 32 console.log(\u0026#39;Something went wrong\u0026#39;, err); 33 }); 34 }); 35 }); 添加 Hugo-admonitions 安装 github\n控制 Markdown 文件中图片的属性 使用 shortcodes，可以自定义使用短代码进行渲染，官方自带了一个 figure\n1\u0026lt;!-- 显示效果 --\u0026gt; 2{{\u0026lt; figure src=\u0026#34;cover.jpg\u0026#34; title=\u0026#34;日落时的大象\u0026#34; \u0026gt;}} 在代码块内书写 Shortcodes时，hugo 会自动解析，要跳过解析需要在 {{\u0026lt; 后加一个反斜杠 /*，在 \u0026gt;}} 前加一个反斜杠 */\n","date":"2025-03-14T23:00:30+08:00","image":"http://localhost:1313/post/hugo/cover.svg","permalink":"http://localhost:1313/post/hugo/","title":"Hugo Stack 个性化修改"},{"content":"HybridCLR + Addressable Unity 使用的Unity版本为2022.3.13f1 安装UnityComponent添加对IL2CPP的支持 参考：Chneixn-Note\nVisual Studio 安装 使用Unity的游戏开发 和 使用C++的游戏开发 套件\n依据你的系统，安装 Window10-SDK 或 Window11-SDK 最新版即可\n框架搭建 安装HybridCLR 安装详看文档\n文档主页：https://hybridclr.doc.code-philosophy.com/docs/beginner/quickstart\n国内Git地址：https://gitee.com/focus-creative-games/hybridclr_unity.git\n国外Git地址：https://github.com/focus-creative-games/hybridclr_unity.git\n创建 Asset/HotUpdate 文件夹\n在 HotUpdate 文件夹创建 HotUpdate 的程序集（Assembly Definition）\n在 HotUpdate 文件夹任意创建一个脚本\n在 Visual Studio 重载项目，此时的解决方案资源管理器应该显示两个程序集，如图\n选择 Unity 的上方菜单项 HybridCLR/Installer...\n选择 Install（安装成功后控制台会打印成功的信息，以及绿框位置显示为 True）\n选择 Unity 的上方菜单项 HybridCLR/Settings...\n在热更新的 Assembly Definition 中添加在 HotUpdate 文件夹中的程序集\nNote 如果没有显示 HybridCLR Settings，重启 Unity\n选择 Unity 的上方菜单项 Edit/Project Settings...\n在左侧选择 Player\n在下方展开 Other Settings\n按照图中选项修改\n选择 Unity 的上方菜单项 HybridCLR/Generate/All\n将 {proj}/HybridCLRData/HotUpdateDlls/StandaloneWindows64(MacOS 下为 StandaloneMacXxx) 目录下的 HotUpdate.dll 重命名为 HotUpdate.dll.bytes，将其复制到 Asset/HotUpdate/Dlls 内（无则新建）\n可选：对项目进行一次打包 在 HotUpdate 文件夹下的所有脚本发生任何变更后，都需要在 Unity 的上方菜单项选择 HybridCLR/CompileDll/ActiveBuildTarget\n安装 Adressable 打开 Package Manager 窗口\n选择 Package: Unity Registry\n搜索 Addressable\n点击 Install 安装\n选择 Unity 的上方菜单项 Window/Asset Management/Addressable/Groups\n选择 Generate...\n选择 Profile：Default\n选择 Manage Profiles\n修改设置\n选择 Remote 为 Custom\n将 Remote.LoadPath 修改为自己的远程或本地的 http 资源服务器，路径内文件为本地的 {project}/ServerData/[BuildTarget]\n点击 Addressables Groups 窗口的 New\n创建一个新的组并命名为 HotUpdateDll\n选择组 HotUpdateDll，在右侧 Inspector 窗口修改 Build \u0026amp; Load Paths 为 Remote\n在 Project 窗口找到 AddressableAssetSettings\n在 Inspector 窗口勾选 Build Remote Catalog\n选择 Asset/HotUpdate/Dlls/HotUpdate.dll\n此时该文件在文件管理器中的后缀应为.bytes 将其拖入 Addressables Groups 窗口的 HotUpdateDll 组内\n可选: 打上标签Dll 选择 Play Mode Script 里的第三项 Use Exiting Build（Window）\n点击 Player Mode... 左侧的 Build，选择 New Build/Defalut Build Script\n此时在 {Project}/ServerData 下会有文件夹为 StandardWindow64 文件夹\n此文件夹内文件需与资源服务器内容同步 脚本热更新操作步骤 在 HotUpdate 文件夹下的所有脚本发生任何变更后，都需要在 Unity 的上方菜单项选择 HybridCLR/CompileDll/ActiveBuildTarget\n在 Addressables Groups 窗口选择 Build/New Build/Defalut Build Script\n同步 ServerData 文件夹内的文件至资源服务器\n运行客户端下载\n在 HotUpdate 文件下的脚本需要注意 在引用其他命名空间时，在客户端有可能会出现 Script Missing 错误\n因此需要选择 HotUpdate 文件夹里的 HotUpdate 程序集\n在 Inspector 勾选 Allow 'unsafe' Code\n在 Assembly Definition Reference 添加引用的命名空间程序集\n在 Assets/StreamingAssets 文件夹放置对应所需的 Dll 文件\n并在客户端的资源检查脚本第一时间读取\n","date":"2025-03-14T23:00:30+08:00","image":"http://localhost:1313/post/hotupdate/cover_hu_147dc9142451a781.png","permalink":"http://localhost:1313/post/hotupdate/","title":"Unity 基于 HybridCLR + Addressable 实现的热更新"},{"content":"SVN 与 Git 的区别 选择 SVN 的场景包括：\n传统团队： 对于一些较老的项目，团队对分布式开发的要求不高，或者团队成员对 SVN 更为熟悉等情况下，选择 SVN 可能更为合适。\n集中式开发： 如果团队成员集中在一个地理位置，或者不需要进行远程协作开发，SVN 的集中式特性可能更符合团队的需求。\n较简单的项目： 对于一些较为简单的项目，SVN 的版本控制功能可能已经足够满足需求，而且相对容易上手。\n选择 Git 的场景包括：\n分布式团队： 如果团队成员分布在不同的地理位置，或者需要进行远程协作开发，Git 的分布式特性能够更好地支持这种开发模式。\n高度并行开发： 如果项目需要进行大规模的并行开发，Git 的分支管理功能能够更好地支持团队成员之间的协作和独立开发。\n大型项目： 对于大型项目或者包含大量文件的项目，Git 在性能方面通常比 SVN 更优秀，能够更快速地进行版本控制和管理。\n开源项目： 许多开源项目选择使用 Git 进行版本控制，因为 Git 的分布式特性能够更好地支持开源社区的协作开发。\n","date":"2025-03-14T21:55:30+08:00","image":"http://localhost:1313/post/svn%E5%92%8Cgit/d6_hu_eaa3cfa3fd97b974.jpeg","permalink":"http://localhost:1313/post/svn%E5%92%8Cgit/","title":"SVN 与 Git 的区别"},{"content":"Unity 引擎相关 1.游戏AI ①常用的做法简述（NavMesh + 寻路）\n②NavMesh的生成过程简述\n顶点\n③A*寻路算法的原理\n广度搜索\n④是否了解多个AI都在自动寻路时的动态避障算法\nRVO 避障算法\n2.物理碰撞 ①如何判断子弹射击到敌人（然后继续问包围盒、碰撞检测算法等），如果子弹特别快怎么办\n特别快：使用射线检测，获取子弹上一帧位置，从上一帧位置到当前位置创建射线\n②BVH、八叉树等场景管理加速结构，在这些树上检测碰撞的过程\n3.网络同步 ①状态同步和帧同步的原理\n②上面两个在反作弊、断线重连、实时性等等场合，用哪种同步策略好\n③TCP和UDP应用上的区别和游戏开发中的使用偏向（不用细说它们的原理）\n4.场景题 ①跳跃到最高点自动开枪，这个功能应该怎么做 从Character Controller 可以获取角色的速度，当角色到达最高点时，其纵向的速度大小为0\n②游戏分辨率变换、窗口尺寸变换时，UI应该怎么适配 Canvas 有 依据窗口缩放的组件，其他 UI 要设置好锚点 ③角色可以穿脱装备，每个装备对角色的血量有不同的buff，该如何设计这个功能\n④水的着色应该写在vertex shader还是fragment shader\n⑤游戏中物体从不透明变成透明，对渲染有什么难度\n5.游戏设计模式 ①单例模式的作用，使用单例模式和只创建一个static对象有什么区别\n②工厂模式，有构造函数为什么还要设计抽象工厂模式\n③观察者模式，MVC是什么、怎样对应观察者模式，观察者模式的应用场景\n6.其他 ①Unity对象生命周期（乍一听不知道是什么意思，实际上是问MonoBehaviour类的tick过程中，各函数调用的顺序，Awake、Update、FixedUpdate、OnDisable等等）\n②让你设计一个游戏引擎UI框架，有什么想法，要考虑什么\n③游戏引擎的RHI是干嘛的\n④游戏开发中的对象池技术是干嘛的\n对象复用，避免高频的生成实例，实例化需要从堆栈分配内存，复用对象以减少GC\n3.4 图形学 对于客户端开发，图形学只是加分项，不算特别重要。我是入门水平，也没有相关的项目，所以被问到的不多，绝大多数公司只让讲一下渲染管线就好了。 1.图形渲染管线，会先让你大致讲一下渲染管线，然后问一些细节问题 ①drawcall是什么，为什么要减小drawcall ②粗细粒度culling的区别 ③MVP、viewport分别进行什么变换 ④深度测试是什么，early-z是什么 ⑤延迟渲染管线是什么，有什么优缺点 ⑥半透明物体的渲染顺序 ⑦shader中为什么要避免使用if语句 2.抗锯齿技术 ①MSAA、SSAA的区别 ②延迟渲染为什么用不了硬件AA ③DLSS原理的简单说明 3.光照模型 ①BRDF概念 ②简单描述blinn-phong光照模型，specular、ambiant、diffuse ③简单描述pbr光照模型，lambert漫反射 + cooktorrence反射（DGF）\n计算机基础 五百年没看了，只记得几个经典知识点，再问详细的实在是忘了。跟面试官说不会，基本上也不会再细究。 编译的过程，几个阶段分别发生什么\n寻址的过程\n虚拟内存空间的概念\n进程和线程的概念\n进程间通信方式\nQ: 进程的多个线程是否共享进程的全部资源\nA: 是，线程共享进程的全局资源，但拥有独立的执行上下文。\n共享的资源：\n内存空间（代码段、堆、全局/静态变量） 打开的文件句柄 子进程/线程 信号处理机制 进程ID等系统资源 不共享的资源：\n每个线程有自己的栈空间（存储局部变量和函数调用信息） 线程自己的寄存器上下文（如程序计数器、通用寄存器等） 线程私有的数据（如线程局部存储TLS） 独立的线程ID Q: 进程切换、线程切换，是否引起上下文切换、用户态/内核态切换\n为什么线程太多会导致性能下降（1s的进程分10个线程，比分100个线程的执行时间要更短，为什么？我答了调度有消耗但面试官不认同）\n怎么发现、定位内存泄漏\nOSI网络模型\nTCP、UDP的区别\n在应用层如何保证UDP的可靠传输\nTCP的三次握手四次挥手\n算法题、数学题、脑筋急转弯 口述：判断扇形攻击命中（2D空间判断点在扇形内）\n口述：2D空间中，在三角形/圆内如何随机并且均匀采样点，均匀是指点各自占的面积尽量均匀\n口述：判断点在三角形内（比较基础，但经常被问。重心坐标、叉乘法、面积求和）\n口述：层次遍历二叉树\n前序、中序、后序\n口述：快速排序\n口述：绳子分成3段，要求三段长度乘积最大\n口述：两个鸡蛋判断最少从哪层楼扔下来会碎，怎么弄比较好\n口述：如何检测链表相交的所有情况，包括有环、在环上相交、入环点不一样等等\n手撕：1、2、3、4、5、6、7、8的链表变成1、8、2、7、3、6、4、5，不使用额外存储空间\n头尾双指针\n手撕：合并n个有序链表\n手撕：有重复元素的顺序数组，查找新来的元素最前面的插入位置\n二分找，最后前后大小不同插入，相同向前找\n手撕：DFS解数独\n手撕：数组的最长递增连续子序列长度\n手撕：两个字符串的最长不连续公共子串（逆天，看一眼直接放弃）\n手撕：链表的倒数第k个元素\n手撕：顺时针90度旋转矩阵\n手撕：数组的第k大元素\n手撕：判断汉字的unicode编码是否合法（题很长，记不清了）\n手撕：判断回文链表，不使用额外存储空间\n参考 回文链表\n","date":"2025-03-14T21:55:30+08:00","permalink":"http://localhost:1313/post/unity%E9%9D%A2%E8%AF%95/","title":"Unity 客户端开发问题笔记"},{"content":"UniTask UniTask 是一个公开库，基于 MIT 协议开源，是 Unity 异步调用的一个方案，该方案性能优越\nForGet 是在同步方法中调用异步方法的一个方式, Fire and forget.\n1public void Call() 2{ 3 Run().Forget(); 4} 5 6private async UniTask Run() 7{ 8 await UniTask.WaitForSeconds(0.02f); 9} Cancel 取消异步操作 C# 在设计异步初衷并不希望我们能控制其他线程的运行，但是在 Unity 中确实有一定的需求需要能取消异步，一般使用以下两种方式取消\n抛出异常式 1private CancellationTokenSource cancelSource; 2 3public async void Run(){ 4 try{ 5 await AsyncMethod(cancelTolen.Token) 6 } 7 catch(OperationCanceledException e){ 8 Debug.Log(\u0026#34;Runner had canceled.\u0026#34;); 9 } 10} 返回值式 1private CancellationTokenSource cancelSource; 2 3public async void Run(){ 4 5 // AsyncMethod 无返回值 6 var result = await AsyncMethod(cancelTolen.Token).SupperessCancellationThrow(); 7 if (result){ 8 // do something 9 } 10 11 // AsyncMethod 有返回值 12 var (result2, returnValue) = await AsyncMethodWithReturnValue(cancelTolen.Token).SupperessCancellationThrow(); 13 if (result2){ 14 // do something 15 } 16 17} 18 19public async UniTask\u0026lt;int\u0026gt; AsyncMethodWithReturnValue(CancellationToken cancelToken){ 20 21 await UniTask.NextFrame(cancelToken) 22 return 0; 23 24} 取消异步操作 在创建异步操作后，取消异步操作\n1public void CallCancel(){ 2 cancelSource.Cancel(); 3 cancelSource.Dispose(); 4 cancelSource = new CancellationTokenSource(); 5} 特别的，有时需要连锁取消的功能\n1private CancellationTokenSource first; 2private CancellationTokenSource second; 3 4private CancellationTokenSource linkedCancelSource; 5 6private void LinkCancelSource(){ 7 8 linkedCancelSource = CancellationTokenSource.CreateLinkedTokenSource(first.Token, second.Token); 9 10} 11 12private CallCancel(){ 13 14 // 此时同时取消两个 Token 15 linkedCancelSource.Cancel(); 16 linkedCancelSource.Dispose(); 17 // 每个 CancellationTokenSource 只能使用一次，所以需要重新创建 18 LinkCancelSource(); 19 20} ","date":"2025-03-08T23:00:30+08:00","image":"http://localhost:1313/post/unitask/Icon_hu_d6c8f6af60bafd44.png","permalink":"http://localhost:1313/post/unitask/","title":"UniTask 学习笔记"},{"content":"Cinemachine 的更新 3.0 Cinemachin e的基本介绍 介绍 - CSDN\nCinemachine Brain Update 方式 描述 FixedUpdate LateUpdate SmartUpdate 比较 FixedUpdate 和 LateUpdate 哪个更新的次数更多，就用哪个，会有一些消耗 ManualUpdate 手动在脚本里调用，目前demo里的用法，在lateupdate里调用，再同步一些物体的旋转，防止抖动 ","date":"2025-03-01T23:00:30+08:00","image":"http://localhost:1313/post/cinemachine/cover_hu_250dd22a4483c14c.jpg","permalink":"http://localhost:1313/post/cinemachine/","title":"Unity Cinemachine 3.0"},{"content":"将 Inspector 扩展应用到子类 1[CustomEditor(typeof(BaseGun), true)] 2public class CustomInspector : Editor{ } 重写 OnInspectorGUI (IMGUI框架) 添加默认显示的 Attribute 1public override void OnInspectorGUI() 2{ 3 // Update the serializedProperty - always do this in the beginning of OnInspectorGUI. 4 serializedObject.Update(); 5 base.OnInspectorGUI(); 6} 示例\n重写 CreateInspectorGUI (UIToolkit框架) 添加默认显示的 Attribute 1public override VisualElement CreateInspectorGUI() 2{ 3 var root = new VisualElement(); 4 root.Add(new IMGUIContainer(OnInspectorGUI)); 5 return root; 6} 使用示例\n1using UnityEditor; 2using UnityEditor.UIElements; 3using UnityEngine.UIElements; 4 5[CustomEditor(typeof(FinalFoodMaker), true)] 6public class FinalFoodMakerEditor : Editor 7{ 8 public override VisualElement CreateInspectorGUI() 9 { 10 var root = new VisualElement(); 11 root.Add(new IMGUIContainer(OnInspectorGUI)); 12 13 var maker = (FinalFoodMaker)target; 14 if (maker.cookBook != null) 15 { 16 SerializedObject obj = new(maker.cookBook); 17 var element = new InspectorElement(obj); 18 element.Bind(obj); 19 root.Add(element); 20 } 21 22 return root; 23 } 24} ","date":"2025-03-01T23:00:30+08:00","permalink":"http://localhost:1313/post/inspecter%E6%8B%93%E5%B1%95/","title":"Unity Inspector 拓展笔记"},{"content":"关于 List 复制一个新的 List 因为 List 是引用类型，直接使用 = 符号，引用的是原来的列表，因此对新列表进行操作，原列表也会改变\nMyClass 在列表中是一个引用类型\n1 List\u0026lt;MyClass\u0026gt; newList = originList; 使用 Linq 中的 ToList() 方法，可以创建一个新的列表，如果列表中的元素为引用类型，列表中的元素将仍是原列表中的元素\n1 List\u0026lt;MyClass\u0026gt; newList = originList.ToList(); switch语句 弃元模式 C#7.0 1var result = score switch 2 { 3 \u0026gt;= 80 =\u0026gt; \u0026#34;excellent\u0026#34;, 4 \u0026gt;= 60 =\u0026gt; \u0026#34;good\u0026#34;, 5 _ =\u0026gt; \u0026#34;poor\u0026#34; //弃元在switch表达式中就相当于default 6 }; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/c%23%E8%AF%AD%E6%B3%95/","title":"C# 语法"},{"content":"PingPong PingPong 返回一个在零和长度之间递增和递减的值。它遵循三角波公式，其中底部设置为零，峰值设置为长度。\nPingPong 要求值 t 是自增量值。例如，Time.time和Time.unscaledTime。\n1var amplitude = 2; // 振幅 2var period = 2; // 一往復する周期（秒） 3var phase = 0.25f; // 位相（１で１周分） 4 5// 位相を考慮した時間補正 6var t = 4 * amplitude * (Time.time / period + phase + 0.25f); 7 8// 指定された振幅、周期、位相のPingPong 9var value = Mathf.PingPong(t, 2 * amplitude) - amplitude; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unitymathf/","title":"Unity Mathf 笔记"},{"content":"像 Alyx 一样抓取物体 Source Video: https://www.youtube.com/watch?v=WU23Uj1oeh8\n基于 Unity XR Interaction Toolkit 2.6.3\nRay Interactor 在 Interaction Layer Mask 设置好交互层级为 Interactable Default\nAnchor Control 选项可选\nGrablale Object 可以抓取的物体需要有 mesh collider 组件\n注意 Interaction Layer Mask 以及 Movement Type 的设置\nXR Alyx Grab Interactable 该脚本继承于 XRGrabInteractable\n功能简介：\n对准可抓取的物体时显示射线，物体会显示描边（可选显示一层覆盖颜色） 按住抓取按键时选中物体 选中物体后将手柄向上提起，物体会向手部位置飞去 ❗飞来的物体需要再次按抓取键才能抓在手上\n下面是脚本代码\n1using System.Collections; 2using System.Collections.Generic; 3using UnityEngine; 4using UnityEngine.XR.Interaction.Toolkit; 5 6public class XRAlyxGrabInteractable : XRGrabInteractable 7{ 8 [Tooltip(\u0026#34;跳跃的速度阈值\u0026#34;)] 9 public float velocityThreshold = 2f; 10 [Tooltip(\u0026#34;跳跃时的角度\u0026#34;)] 11 public float jumpAngleInDegree = 60f; 12 13 private XRRayInteractor rayInteractor; 14 private Vector3 previousPos; 15 private Rigidbody rb; 16 private bool canJump = true; 17 18 protected override void Awake() 19 { 20 base.Awake(); 21 rb = GetComponent\u0026lt;Rigidbody\u0026gt;(); 22 } 23 24 private void Update() 25 { 26 if (isSelected \u0026amp;\u0026amp; canJump \u0026amp;\u0026amp; firstInteractorSelecting is XRRayInteractor) 27 { 28 // 当物体被抓住时，计算速度是否超过阈值，超过则执行跳跃 29 Vector3 velocity = (rayInteractor.transform.position - previousPos) / Time.deltaTime; 30 previousPos = rayInteractor.transform.position; 31 if (velocity.magnitude \u0026gt; velocityThreshold) 32 { 33 // 脱离抓取 34 Drop(); 35 // 计算跳跃初速度 36 rb.velocity = ComputeVelocity(transform.position, rayInteractor.transform.position, jumpAngleInDegree, Physics.gravity.y); 37 canJump = false; 38 } 39 } 40 } 41 42 /// \u0026lt;summary\u0026gt; 43 /// 基于重力计算弹道轨迹，计算从自身跳跃到指定地点的跳跃速度 44 /// \u0026lt;/summary\u0026gt; 45 /// \u0026lt;param name=\u0026#34;selfPos\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; 46 /// \u0026lt;param name=\u0026#34;targetPos\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; 47 /// \u0026lt;param name=\u0026#34;jumpAngle\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; 48 /// \u0026lt;param name=\u0026#34;gravity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; 49 /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; 50 public static Vector3 ComputeVelocity(Vector3 selfPos, Vector3 targetPos, float jumpAngle, float gravity) 51 { 52 Vector3 diff = targetPos - selfPos; 53 Vector3 diffXZ = new(diff.x, 0, diff.z); 54 float diffXZLength = diffXZ.magnitude; 55 float diffYLength = diff.y; 56 57 float angleInRadian = Mathf.Clamp(diff.normalized.y * 90, jumpAngle, 90) * Mathf.Deg2Rad; 58 59 float jumpSpeed = Mathf.Sqrt(-gravity * Mathf.Pow(diffXZLength, 2) 60 / (2 * Mathf.Cos(angleInRadian) * Mathf.Cos(angleInRadian) * (diffXZ.magnitude * Mathf.Tan(angleInRadian) - diffYLength))); 61 62 Vector3 jumpVelocityVector = jumpSpeed * Mathf.Cos(angleInRadian) * diffXZ.normalized + jumpSpeed * Mathf.Sin(angleInRadian) * Vector3.up; 63 64 return jumpVelocityVector; 65 } 66 67 protected override void OnSelectEntered(SelectEnterEventArgs args) 68 { 69 // 控制器检测 只响应射线交互器 70 if (args.interactableObject is XRRayInteractor) 71 { 72 trackPosition = false; 73 trackRotation = false; 74 throwOnDetach = false; 75 76 rayInteractor = (XRRayInteractor)args.interactorObject; 77 previousPos = rayInteractor.transform.position; 78 canJump = true; 79 } 80 else 81 { 82 trackPosition = true; 83 trackRotation = true; 84 throwOnDetach = true; 85 } 86 87 base.OnSelectEntered(args); 88 } 89} ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unityxr-alxygrab/","title":"Unity XR 像 Alyx 一样抓取物体"},{"content":"继承 MonoBehaviour 跨场景调用 1using UnityEngine; 2 3namespace UnityUtils 4{ 5 /// \u0026lt;summary\u0026gt; 6 /// 跨场景使用的Mono单例基类 7 /// \u0026lt;/summary\u0026gt; 8 /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt; 9 public class PersistentSingleton\u0026lt;T\u0026gt; : MonoBehaviour where T : Component 10 { 11 public bool AutoUnparentOnAwake = true; 12 13 protected static T instance; 14 15 public static bool HasInstance =\u0026gt; instance != null; 16 public static T TryGetInstance() =\u0026gt; HasInstance ? instance : null; 17 18 public static T Instance 19 { 20 get 21 { 22 if (instance == null) 23 { 24 instance = FindAnyObjectByType\u0026lt;T\u0026gt;(); 25 if (instance == null) 26 { 27 var go = new GameObject(typeof(T).Name + \u0026#34; Auto-Generated\u0026#34;); 28 instance = go.AddComponent\u0026lt;T\u0026gt;(); 29 } 30 } 31 32 return instance; 33 } 34 } 35 36 /// \u0026lt;summary\u0026gt; 37 /// Make sure to call base.Awake() in override if you need awake. 38 /// \u0026lt;/summary\u0026gt; 39 protected virtual void Awake() 40 { 41 InitializeSingleton(); 42 } 43 44 protected virtual void InitializeSingleton() 45 { 46 if (!Application.isPlaying) return; 47 48 if (AutoUnparentOnAwake) 49 { 50 transform.SetParent(null); 51 } 52 53 if (instance == null) 54 { 55 instance = this as T; 56 DontDestroyOnLoad(gameObject); 57 } 58 else 59 { 60 if (instance != this) 61 { 62 Destroy(gameObject); 63 } 64 } 65 } 66 } 67} 同场景调用 1using System.Collections; 2using System.Collections.Generic; 3using UnityEngine; 4 5/// \u0026lt;summary\u0026gt; 6/// 单例模式基类 同场景内使用 7/// \u0026lt;/summary\u0026gt; 8/// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;子类\u0026lt;/typeparam\u0026gt; \u0026lt;summary\u0026gt; 9public class SameSceneSingleMono\u0026lt;T\u0026gt; : MonoBehaviour where T : SameSceneSingleMono\u0026lt;T\u0026gt; 10{ 11 public static T Instance; 12 13 protected virtual void Awake() 14 { 15 if (Instance != null) 16 Debug.LogError(this + \u0026#34;出现多个单例!\u0026#34;); 17 Instance = (T)this; 18 } 19 20 protected void OnDestroy() 21 { 22 Destroy(); 23 } 24 25 public void Destroy() 26 { 27 Instance = null; 28 } 29} ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/singleton/","title":"Unity 单例"},{"content":"判断Animator中是否存在动画 Unity中的animator是以哈希值存储动画状态的索引，先通过动画片段名字字符串获取哈希值，再用HasState这个API获取存在状态\n再通过animator.CrossFadeInFixedTime(animationName, time);过渡动画\n1string animationName; 2int stateID = Animator.StringToHash(animationName) 3bool hasAnimation = animator.HasState(layerIndex, stateID) ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/animation-api/","title":"Unity 动画 API"},{"content":"基于 Unity.InputSystem 和下推状态机的输入系统解决方案 原贴地址：王子饼干 - 知乎\nUnity.InputStstem的优点 InputSystem的优点在于它能够便捷的识别不同设备的按键输入，并使同一动作对不同设备的输入做出响应。\n原生提供了开启和阻断输入的方法，以及切换绑定按键的方式。\n代理控制器 创建 DRockBridge 作为一个代理控制器来接收 InputSystem 的控制，然后这个代理对象再去控制上层游戏对象。\n这样的 InputSystem 只需要与 Bridge 交流，游戏对象也只需要从 Bridge 接受输入。\n同时也只需要在 Bridge 中切换绑定按键，而不影响游戏对象。\n创建通用状态机 为什么要用状态机来管理所有控制对象，简单来说，大部分的时候只有一个控制器是有效的，而这个控制器被激活时也往往伴随着它要控制的 GameObject 的激活。比如打开主菜单时，代码需要激活主菜单，与此同时关闭角色控制器并打开 UI 控制器。\n在主菜单的某个选项选中时，有可能会打开一个子菜单，也有可能会进入一个特殊的模式，比如有的游戏存在建造模式，或者打开了什么商店等。假设我们把打开一个子菜单也视为一个游戏 API 功能的话，肯定要为其单独增加一个函数。首先肯定要关闭主菜单，其次如果我们打开的不是子菜单，而是某个特殊的模式，还要启动对应的控制器，并关闭现有的控制器。\n所以为了解决上述问题，可以将控制器和被控制对象视为一个整体，或者一整个状态。这样启动控制器的同时就启动被控制对象。这样会使得控制器的阻断更加紧凑，或者说，不再需要手动管理。\n这样做更好的一点是，此后我们可以将游戏的控制逻辑视为多个状态。这样只要定义好数个状态对象，此后管理所有的状态对象即可。不需要再在单独的函数中设置输入是否关闭或者开启。\n下推状态机 下推状态机有一个 buffer 缓存区和一个 stack 栈区。在 buffer 缓存区的是当前状态，该状态决定了接收 Bridge 中的什么输入，阻断什么输入。\n当有新状态推入 Buffer 缓存区时，先前的状态就推入 Stack 栈区中。\n以此类推当新状态推入时。\n当 Buffer 缓存区的状态退出时，就从 Stack 栈区中推出上一个状态，可以解决主菜单与子菜单等的衔接。\n并且可以在状态切换时添加更多的细致的动作逻辑。\n例如：\n当状态从外界被推入临时位时，执行 OnEnter 函数\n当状态从临时位被移除时，执行 OnExit 函数\n当状态从临时位被压入栈区时，执行 OnPause 函数\n当状态从栈区被回滚到临时位时，执行 OnResume 函数\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/input/","title":"Unity 基于下推状态机的输入系统解决方案"},{"content":"不支持 Unity 序列化的字段 静态字段 static fields\n只读字段 readonly fields\n常量 const fields\n未带有 [field: SerializeFied] 特性的属性\n支持 Unity 序列化的字段 公开的 非静态 非只读 非常量 字段\npublic non-static non-readonly non-const fields\n带有 [SerialzeFied] 的非静态 非只读 非常量 字段\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unity%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Unity 序列化笔记"},{"content":"3D Demo 特点 Reliable FPS System 可靠的fps系统\nSmooth Control And Responsive 流畅的控制和灵敏的反应\nFullbody System 全身渲染和运动系统\n功能模块 UI框架（TODO） 基于Dotween进行UI动效制作\n存档系统✓ 利用双列表建立可序列化字典，进行游戏数据记录，存档时转为JSON文件实现数据持久化保存和读取\n库存系统✓ 基于ScriptableObject的物品数据库\n交互操作✓ Camera✓ 使用Unity提供的Cinemachine进行相机管理，实现第一人称视角与第三人称视角的相机跟随\n角色控制系统（Doing） 基于Unity.InputSystem和下推状态机的输入系统解决方案\n角色运动状态机\n角色胶囊体运动模拟计算使用KCC插件管理\n多载具控制\n音效系统（TODO） Wwise\n资源管理与热更新✓ 使用AssetsAddressable进行远程资源加载，使用HybridCLR+Addressables实现热更新\n泛型对象池✓ 基于纯C#类的泛型对象池，可扩展实现继承MonoBehavior的对象池，从而减少实例化次数，优化游戏性能\n角色动画 第三人称动画与角色状态匹配\n行为树 AI 寻路算法 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/demo%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BB%BB%E5%8A%A1%E8%A1%A8/","title":"Unity 学习 Demo 的模块任务表"},{"content":"Code 继承于unityobject的类的判空，unity对于 == 进行了重构，会带来GC消耗，因此尽量不要在update处进行判空\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unity%E4%BC%98%E5%8C%96%E6%B3%A8%E6%84%8F/","title":"Unity 优化笔记"},{"content":"行为树 示例 僵尸 AI 特点 僵尸 AI 能根据自身情况（生命值，中枪与否）和外部条件（周围是否存在玩家），采取合理的行动。\nAI基础 基本行为操控（靠近，远离，追逐，逃避\u0026hellip;）\n寻路能力（从游戏场景中一个位置移动到另一个位置，最短路径）\n感知能力（自身状态如血量，听觉和视觉等感知能力）\n自主决策能力（根据自身状态和外部条件作出合理的反应）\n基本行为操控 基本运动：行走，奔跑\n高级运动：跳跃，攀爬，躲避\n攻击：近身攻击，远程攻击，破坏障碍物\n寻路 使用 Unity 的 Navigation 导航系统，实现自动寻路。\n感知能力 视觉 能够感知到玩家是否在视野范围内，视野内是否有障碍物\n听觉 能够感知到玩家的脚步声，枪声，环境噪声（如爆炸，器械启动）\n受击反馈 在受到伤害时（如玩家攻击，爆炸等），会有受击动作，同时能感知到伤害来源\n自主决策能力 实现方式有：有限状态机，行为树，行为树与有限状态机结合\n有限状态机（Finite State Machine） 稍微复杂的僵尸逻辑\n僵尸的感知范围内没有玩家时-\u0026gt;僵尸随机游荡\n僵尸受到攻击-\u0026gt;僵尸向开枪时所在的方向进行搜索\n僵尸感知到玩家-\u0026gt;僵尸追踪玩家\n玩家进入僵尸攻击范围-\u0026gt;僵尸攻击玩家\n玩家死亡或脱离僵尸感知范围-\u0026gt;僵尸回到随机游荡\n僵尸生命值变为0-\u0026gt;僵尸进入死亡状态\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E6%A0%91%E7%9A%84ai/","title":"基于行为树的 AI"},{"content":"类鸟群行为（集群行为） 有时在游戏中为了添加沉浸感，会在深海环境，自然开放环境加入鸟群，鱼群。如何控制鸟群的运动，使其符合现实，不会突兀，且性能友好是该部分讨论的内容。\n参考视频：https://www.youtube.com/watch?v=bqtqltqcQhw\n国内视频翻译：https://www.bilibili.com/video/BV1VJ411y7wE/\n鸟群中每只鸟有以下三个规则：\n偏离附近的其他鸟（分离）\n迎合附近鸟群，转向同一方向（对齐）\n会自行向附近的鸟群中心飞去（凝聚）\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ai%E6%A8%A1%E5%9D%97-%E9%9B%86%E7%BE%A4%E8%A1%8C%E4%B8%BA/","title":"集群行为 AI子模块"},{"content":"模块化角色控制状态机 在我的 3D Demo 中，我需要控制一个具有高可扩展性的角色控制器，因此对其开始探究\n由于对引擎代码的理解不深，也暂时没有什么兴趣研究，因此选择了基于 KCC 角色控制器框架进行开发\n文章引用：\n有限状态机的实现与使用 Kinematic Character Controller CharacterControl 继承 MonoBehaviour, ICharacterController\n角色的控制器，也是这个模块最重要的一个组件\n担任 MVC 模式中 Controller 角色\n所有的状态模块在实例化后都需要在 CreateFSM 方法中加入 FSM 中才能被角色启用\n1private void CreateFSM() 2 { 3 // 在创建状态机时输入第一个状态 4 FSM = new(idle, this); 5 FSM.AddState(fly); 6 FSM.AddState(inAir); 7 FSM.AddState(crouching); 8 } IMovementState 继承 ICharacterController\n状态模块的基类，所有自定义的状态模块都需要继承该类\n在 HandleStateChange(ref PlayerCharacterInput inputs) 方法中实现状态变换的操作\nGravityConfig 用于设定角色的重力\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/charactercontrol/","title":"库存管理系统"},{"content":"库存管理模块 Inventory System 功能实现 编辑器功能（Editor） 列表显示物品库里所有物品 新增 Item 可以自动赋予 ID 允许编辑 ID 增加 Tip 提示 增加 Item 搜索功能 增加从 Excel 导入导出功能 增加从 JSON 导入导出功能 Item 可以使用 ItemType 进行分类显示 游戏内界面（UI） 塔科夫式背包\n背包固定格子，每个物品需要占用不同的格子大小 支持拖拽移动背包物品 支持给可使用物品设置使用热键 显示快捷物品栏\n允许在快捷物品栏滚轮切换物品选择 动态调整快捷物品栏容量 背包界面\n允许鼠标拖拽物品 组合键获取一半的物品 核心代码（Code） ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"库存管理系统"},{"content":"随机洗牌 Knuth-Durstenfeld Shuffle 算法时间复杂度 O(n)\n算法空间复杂度 O(1)\n假设有这样一个数组 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们使用 Knuth-Shuffle 算法将数据打乱。\n基本流程是这样的，从最后一个数开始，往前遍历，每一次，从当前数和第 1 个数之间，随机选择一个数，与当前数字进行交换（这里的随机选择就直接使用程序语言中的 Random 随机一个索引即可）。\n例如上面的数组，第一次循环，当前数字为 10，我们从 1~10 之间，随机选择一个数，与 10 交换，这样第 9 个索引位就算洗完了，接下来就是第 8 个索引位，也就是数字为 9，我们从第 1 个索引位与第 8 个索引位之间，选择一个数，第 9 交换，这样第 8 个索引位也就洗完了\u0026hellip;\n这个算法之所以公平，是因为保证了每一个元素出现在每一个位置上的概率，都是一样的。\n1using System; 2using System.Collections.Generic; 3 4class Program 5{ 6 static void Main(string[] args) 7 { 8 List\u0026lt;int\u0026gt; songList = new List\u0026lt;int\u0026gt;(); 9 songList.Add(1); 10 songList.Add(2); 11 songList.Add(3); 12 songList.Add(4); 13 songList.Add(5); 14 songList.Add(6); 15 songList.Add(7); 16 songList.Add(8); 17 songList.Add(9); 18 songList.Add(10); 19 20 Random rand = new Random(); 21 22 // 开始洗牌算法 23 int last = songList.Count - 1; 24 for (int i = last; i \u0026gt;= 0; --i) 25 { 26 // 从当0~当前索引位之间，选择一个数 27 int selection = rand.Next(i + 1); 28 29 // 索引位对应的数据交换 30 int temp = songList[i]; 31 songList[i] = songList[selection]; 32 songList[selection] = temp; 33 } 34 35 // 打印洗牌后的List 36 for (int i = 0; i \u0026lt; songList.Count; ++i) 37 { 38 Console.Write(songList[i] + \u0026#34; \u0026#34;); 39 } 40 41 } 42} ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E6%B4%97%E7%89%8C/","title":"随机洗牌算法"},{"content":"动态避障算法 RVO RVO是基于VO算法的优化\n源码作者Github：https://github.com/snape\nRVO仓库：https://gamma.cs.unc.edu/RVO2/\nUnity实现例子：https://github.com/warmtrue/RVO2-Unity/tree/master\nRVO算法的优化：\nORCA**（Optimal Reciprocal Collision Avoidance）**\nORCA中文文档：https://blog.csdn.net/u012740992/article/details/89397714\n结合A*寻路与ORCA的项目：https://arongranberg.com/astar/front\n文章：\nMotion Planning in Dynamic Environments Using Velocity Obstacles\nhttps://ieeexplore.ieee.org/document/292038\nReciprocal Velocity Obstacles for real-time multi-agent navigation\nhttps://www.academia.edu/93509158/Reciprocal_Velocity_Obstacles_for_real_time_multi_agent_navigation\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ai%E6%A8%A1%E5%9D%97-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/","title":"寻路算法"}]
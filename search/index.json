[{"content":"SVN 与 Git 的区别 选择 SVN 的场景包括：\n传统团队： 对于一些较老的项目，团队对分布式开发的要求不高，或者团队成员对 SVN 更为熟悉等情况下，选择 SVN 可能更为合适。\n集中式开发： 如果团队成员集中在一个地理位置，或者不需要进行远程协作开发，SVN 的集中式特性可能更符合团队的需求。\n较简单的项目： 对于一些较为简单的项目，SVN 的版本控制功能可能已经足够满足需求，而且相对容易上手。\n选择 Git 的场景包括：\n分布式团队： 如果团队成员分布在不同的地理位置，或者需要进行远程协作开发，Git 的分布式特性能够更好地支持这种开发模式。\n高度并行开发： 如果项目需要进行大规模的并行开发，Git 的分支管理功能能够更好地支持团队成员之间的协作和独立开发。\n大型项目： 对于大型项目或者包含大量文件的项目，Git 在性能方面通常比 SVN 更优秀，能够更快速地进行版本控制和管理。\n开源项目： 许多开源项目选择使用 Git 进行版本控制，因为 Git 的分布式特性能够更好地支持开源社区的协作开发。\n","date":"2025-03-14T21:55:30+08:00","permalink":"http://localhost:1313/post/svn%E5%92%8Cgit/","title":"SVN 与 Git 的区别"},{"content":"3.3 游戏开发问题\n关于游戏开发的通用问题。各个模块会再问一些特定引擎的问题，对照上面的3.2。\n1.游戏AI\n①常用的做法简述（NavMesh + 寻路）\n②NavMesh的生成过程简述\n③A*寻路算法的原理\n④是否了解多个AI都在自动寻路时的动态避障算法\n2.物理碰撞\n①如何判断子弹射击到敌人（然后继续问包围盒、碰撞检测算法等），如果子弹特别快怎么办\n②BVH、八叉树等场景管理加速结构，在这些树上检测碰撞的过程\n3.网络同步\n①状态同步和帧同步的原理\n②上面两个在反作弊、断线重连、实时性等等场合，用哪种同步策略好\n③TCP和UDP应用上的区别和游戏开发中的使用偏向（不用细说它们的原理）\n4.场景题\n①跳跃到最高点自动开枪，这个功能应该怎么做\n②游戏分辨率变换、窗口尺寸变换时，UI应该怎么适配\n③角色可以穿脱装备，每个装备对角色的血量有不同的buff，该如何设计这个功能\n④水的着色应该写在vertex shader还是fragment shader\n⑤游戏中物体从不透明变成透明，对渲染有什么难度\n5.游戏设计模式\n①单例模式的作用，使用单例模式和只创建一个static对象有什么区别\n②工厂模式，有构造函数为什么还要设计抽象工厂模式\n③观察者模式，MVC是什么、怎样对应观察者模式，观察者模式的应用场景\n6.其他\n①Unity对象生命周期（乍一听不知道是什么意思，实际上是问MonoBehaviour类的tick过程中，各函数调用的顺序，Awake、Update、FixedUpdate、OnDisable等等）\n②让你设计一个游戏引擎UI框架，有什么想法，要考虑什么\n③游戏引擎的RHI是干嘛的\n④游戏开发中的对象池技术是干嘛的\n3.4 图形学\n对于客户端开发，图形学只是加分项，不算特别重要。我是入门水平，也没有相关的项目，所以被问到的不多，绝大多数公司只让讲一下渲染管线就好了。\n1.图形渲染管线，会先让你大致讲一下渲染管线，然后问一些细节问题\n①drawcall是什么，为什么要减小drawcall\n②粗细粒度culling的区别\n③MVP、viewport分别进行什么变换\n④深度测试是什么，early-z是什么\n⑤延迟渲染管线是什么，有什么优缺点\n⑥半透明物体的渲染顺序\n⑦shader中为什么要避免使用if语句\n2.抗锯齿技术\n①MSAA、SSAA的区别\n②延迟渲染为什么用不了硬件AA\n③DLSS原理的简单说明\n3.光照模型\n①BRDF概念\n②简单描述blinn-phong光照模型，specular、ambiant、diffuse\n③简单描述pbr光照模型，lambert漫反射 + cooktorrence反射（DGF）\n3.5 计算机基础\n五百年没看了，只记得几个经典知识点，再问详细的实在是忘了。跟面试官说不会，基本上也不会再细究。\n编译的过程，几个阶段分别发生什么\n寻址的过程\n虚拟内存空间的概念\n进程和线程的概念\n进程间通信方式\n进程的多个线程是否共享进程的全部资源\n进程切换、线程切换，是否引起上下文切换、用户态/内核态切换\n为什么线程太多会导致性能下降（1s的进程分10个线程，比分100个线程的执行时间要更短，为什么？我答了调度有消耗但面试官不认同）\n怎么发现、定位内存泄漏\nOSI网络模型\nTCP、UDP的区别\n在应用层如何保证UDP的可靠传输\nTCP的三次握手四次挥手\n3.6 算法题、数学题、脑筋急转弯\n口述：判断扇形攻击命中（2D空间判断点在扇形内）\n口述：2D空间中，在三角形/圆内如何随机并且均匀采样点，均匀是指点各自占的面积尽量均匀\n口述：判断点在三角形内（比较基础，但经常被问。重心坐标、叉乘法、面积求和）\n口述：层次遍历二叉树\n口述：快速排序\n口述：绳子分成3段，要求三段长度乘积最大\n口述：两个鸡蛋判断最少从哪层楼扔下来会碎，怎么弄比较好\n口述：如何检测链表相交的所有情况，包括有环、在环上相交、入环点不一样等等\n手撕：1、2、3、4、5、6、7、8的链表变成1、8、2、7、3、6、4、5，不使用额外存储空间\n手撕：合并n个有序链表\n手撕：有重复元素的顺序数组，查找新来的元素最前面的插入位置\n手撕：DFS解数独\n手撕：数组的最长递增连续子序列长度\n手撕：两个字符串的最长不连续公共子串（逆天，看一眼直接放弃）\n手撕：链表的倒数第k个元素\n手撕：顺时针90度旋转矩阵\n手撕：数组的第k大元素\n手撕：判断汉字的unicode编码是否合法（题很长，记不清了）\n手撕：判断回文链表，不使用额外存储空间\n","date":"2025-03-14T21:55:30+08:00","permalink":"http://localhost:1313/post/unity%E9%9D%A2%E8%AF%95/","title":"Unity 客户端开发问题笔记"},{"content":"switch语句 弃元模式 C#7.0 var result = score switch { \u0026gt;= 80 =\u0026gt; \u0026#34;excellent\u0026#34;, \u0026gt;= 60 =\u0026gt; \u0026#34;good\u0026#34;, _ =\u0026gt; \u0026#34;poor\u0026#34; //弃元在switch表达式中就相当于default }; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/c%23switch/","title":"C# Switch 语法"},{"content":"总字数统计 “发表了x篇文章，共计x字” 在 layouts/partials/footer/footer.html 文件中添加以下代码\n参考 第三夏尔-添加总字数统计\n\u0026lt;!-- Add total page and word count time --\u0026gt; \u0026lt;section class=\u0026#34;totalcount\u0026#34;\u0026gt; {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} 发表了{{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }}篇文章 · 总计{{ div ($scratch.Get \u0026#34;total\u0026#34;) 1000.0 | lang.FormatNumber 2 }}k字 \u0026lt;/section\u0026gt; 在assets/scss/partials/footer.scss里修改风格:\n.totalcount { color: var(--card-text-color-secondary); font-weight: normal; margin-bottom: 5px; } 修改目录滚动条样式 当文章的目录太长时便会产生滚动条，默认的滚动条样式比较丑陋，所以可以修改成如下样式\n{ ::-webkit-scrollbar { width: 20px; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } } 支持数学公式编辑 使文章能够支持数学公式的编辑\n我们需要在主题根目录的 /layouts/partials 创建 math.html 文件，之后在这个文件中加入如下代码\n{{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这段代码能够自动渲染数学公式，当然这样还是不够的，我们还需要在每篇文章的 markdown 的 header 加上 math=\u0026quot;true\u0026quot; 的选择字段。\n代码块相关 自定义代码字体 参考 某菜鸡的垃圾站\n在站点文件夹（注意不是主题文件夹）下新建 layouts/partials/head/custom.html\n\u0026lt;style\u0026gt; /* Overwrite CSS variable */ :root { --code-font-family: \u0026#34;JetBrains Mono\u0026#34;; /* 按需修改 */ } code { font-size: 1.4rem; /* font size */ } pre { font-size: 1.4rem; /* font size */ } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; (function () { const customFont = document.createElement(\u0026#39;link\u0026#39;); customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=JetBrains Mono:wght@300;700\u0026amp;display=swap\u0026#34;; /* 按需修改 */ customFont.type = \u0026#34;text/css\u0026#34;; customFont.rel = \u0026#34;stylesheet\u0026#34;; document.head.appendChild(customFont); }()); \u0026lt;/script\u0026gt; 代码块固定高度 参考 Naive Koala\n过长的内容影响观感，所以把 block 的高度限制在 35em，并隐藏滚动条\n在 /assets/scss/partials/layout/article.scss 中进行如下修改（已隐藏无关片段）\n.article-content { // line 205 .highlight { // line 331 background-color: var(--pre-background-color); - padding: var(--card-padding); position: relative; pre { // line 345 margin: initial; padding: 0; margin: 0; width: auto; + max-height: 35em; + scrollbar-width: none; /* Firefox */ + \u0026amp;::-webkit-scrollbar { + display: none; /* Chrome Safari */ + } } } } 关于 Dark Reader 参考 某菜鸡的垃圾站\n该主题的暗色模式无法被dark reader检测到\n在在文件 layouts/partials/head/head.html 里 viewport 下面加了一句 \u0026lt;meta name=\u0026quot;color-scheme\u0026quot; content=\u0026quot;dark\u0026quot;\u0026gt;\n使图床链接的图片居中 参考 Naive Koala\n目前 Stack 默认只支持本地引用的图片居中，而在使用 url 图片链接时没有居中格式\n在 /assets/scss/partials/layout/article.scss Line 256 处（同级任意位置）增加以下代码\n// Center image from url source p \u0026gt; img { display: block; margin: 0 auto; max-width: 100%; height: auto; } 头像旋转 参考 Naive Koala\n在 /assets/scss/custom.scss 中加入以下代码\n// 头像旋转动画 .sidebar header .site-avatar .site-logo { transition: transform 1.65s ease-in-out; // 旋转时间 } .sidebar header .site-avatar .site-logo:hover { transform: rotate(360deg); // 旋转角度为360度 } 修改正文占比 参考 Naive Koala\n在 /assets/scss/grid.scss 中修改 left-sidebar 和 right-sidebar 的描述\n.left-sidebar { order: -3; // max-width: var(--left-sidebar-max-width); max-width: 10%; } .right-sidebar { order: -1; // max-width: var(--right-sidebar-max-width); max-width: 22%; /// Display right sidebar when min-width: lg @include respond(lg) { display: flex; } } 首页欢迎横幅 参考 Naive Koala\n在 /layouts/index.html 的 \u0026lt;section class=\u0026quot;article-list\u0026quot;\u0026gt; 前添加以下代码\n\u0026lt;!-- 首页欢迎字幅 --\u0026gt; \u0026lt;div class=\u0026#34;welcome\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 2rem; text-align: center; font-weight: bold\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;shake\u0026#34;\u0026gt;👋\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text1\u0026#34; \u0026gt; Welcome\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text2\u0026#34;\u0026gt; To \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text3\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Xa\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text4\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;l\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text5\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text6\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;o\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text7\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;k\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text8\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;\u0026#39;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text9\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Blog\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 首页欢迎字幅 --\u0026gt; 在 /assets/scss/custom.scss 中加入以下代码\n//首页欢迎板块样式 .welcome { color: var(--card-text-color-main); background: var(--card-background); box-shadow: var(--shadow-l2); border-radius: 30px; display: inline-block; } // 👋emoji实现摆动效果 .shake { display: inline-block; animation: shake 1s; animation-duration: 1s; animation-timing-function: ease; animation-delay: 0s; animation-iteration-count: 1; animation-direction: normal; animation-fill-mode: none; animation-play-state: running; animation-name: shake; animation-timeline: auto; animation-range-start: normal; animation-range-end: normal; animation-delay: 2s; @keyframes shake { 0% { transform: rotate(0); } 25% { transform: rotate(45deg) scale(1.2); } 50% { transform: rotate(0) scale(1.2); } 75% { transform: rotate(45deg) scale(1.2); } 100% { transform: rotate(0); } } } // 实现字符跳动动画 .jump-text1 { display: inline-block; animation: jump 0.5s 1; } .jump-text2 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.1s; } .jump-text3 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.2s; } .jump-text4 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.3s; } .jump-text5 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.4s; } .jump-text6 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.5s; } .jump-text7 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.6s; } .jump-text8 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.7s; } .jump-text9 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.9s; } @keyframes jump { 0% { transform: translateY(0); } 50% { transform: translateY(-20px); } 100% { transform: translateY(0); } } 使用 GitAction 部署时 将 git 时间作为文件更新时间 参考 serenNan\n修改 /.github/workflows/deploy.yml\njobs: build-deploy: runs-on: ubuntu-latest # runs-on: macos-latest steps: - name: Check out source uses: actions/checkout@v4 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false - name: Setup hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.145.0\u0026#34; # \u0026#34;latest\u0026#34; 可以修改为你使用的 Hugo 版本 extended: true # 设置是否需要 extended 版本 修改 hugo.yaml\n# 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: [\u0026#34;:git\u0026#34;,\u0026#34;:fileModTime\u0026#34;] enableGitInfo: true # 允许获取Git信息 在主页文章卡片显示创建时间和阅读时长 在 layouts/partials/article/components/details.html 添加\n\u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; \u0026lt;!-- 创建最后更新时间 --\u0026gt; {{ if and $showDate (ne .Lastmod .Date) }} \u0026lt;span class=\u0026#34;time-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-time--lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} 添加评论功能 giscus 参考 serenNan\n参考 意琦行\n添加行号后复制代码会复制行号的问题 参考 B1ain\u0026rsquo;s Blog\n1.首先解决手动选中内容复制带行号的问题\n在 assets/scss/custom.scss 文件中添加如下内容，将行号设定为不可选中\n// 禁止复制行号 .highlight .ln { user-select: none; } 2.解决copy按钮复制带行号的问题\n修改 themes/hugo-theme-stack/assets/ts/main.ts 文件中的复制按钮逻辑\nhighlights.forEach(highlight =\u0026gt; { const copyButton = document.createElement(\u0026#39;button\u0026#39;); copyButton.innerHTML = copyText; copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); highlight.appendChild(copyButton); const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); if (!codeBlock) return; copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { // 创建一个临时容器来克隆代码块的内容 const tempCodeBlock = codeBlock.cloneNode(true) as HTMLElement; // 删除行号，行号的元素是 \u0026lt;span class=\u0026#34;ln\u0026#34;\u0026gt; const lineNumbers = tempCodeBlock.querySelectorAll(\u0026#39;.ln\u0026#39;); lineNumbers.forEach(lineNumber =\u0026gt; lineNumber.remove()); // 获取没有行号的纯文本内容 const codeText = tempCodeBlock.textContent; navigator.clipboard.writeText(codeText || \u0026#39;\u0026#39;) // navigator.clipboard.writeText(codeBlock.textContent) .then(() =\u0026gt; { copyButton.textContent = copiedText; setTimeout(() =\u0026gt; { copyButton.textContent = copyText; }, 1000); }) .catch(err =\u0026gt; { alert(err) console.log(\u0026#39;Something went wrong\u0026#39;, err); }); }); }); ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/hugo-stack/","title":"Hugo Stack 个性化修改"},{"content":"UniTask UniTask 是一个公开库，基于 MIT 协议开源，是 Unity 异步调用的一个方案，该方案性能优越\nForGet 是在同步方法中调用异步方法的一个方式, Fire and forget.\npublic void Call() { Run().Forget(); } private async UniTask Run() { await UniTask.WaitForSeconds(0.02f); } Cancel 取消异步操作 C# 在设计异步初衷并不希望我们能控制其他线程的运行，但是在 Unity 中确实有一定的需求需要能取消异步，一般使用以下两种方式取消\n抛出异常式 private CancellationTokenSource cancelSource; public async void Run(){ try{ await AsyncMethod(cancelTolen.Token) } catch(OperationCanceledException e){ Debug.Log(\u0026#34;Runner had canceled.\u0026#34;); } } 返回值式 private CancellationTokenSource cancelSource; public async void Run(){ // AsyncMethod 无返回值 var result = await AsyncMethod(cancelTolen.Token).SupperessCancellationThrow(); if (result){ // do something } // AsyncMethod 有返回值 var (result2, returnValue) = await AsyncMethodWithReturnValue(cancelTolen.Token).SupperessCancellationThrow(); if (result2){ // do something } } public async UniTask\u0026lt;int\u0026gt; AsyncMethodWithReturnValue(CancellationToken cancelToken){ await UniTask.NextFrame(cancelToken) return 0; } 取消异步操作 在创建异步操作后，取消异步操作\npublic void CallCancel(){ cancelSource.Cancel(); cancelSource.Dispose(); cancelSource = new CancellationTokenSource(); } 特别的，有时需要连锁取消的功能\nprivate CancellationTokenSource first; private CancellationTokenSource second; private CancellationTokenSource linkedCancelSource; private void LinkCancelSource(){ linkedCancelSource = CancellationTokenSource.CreateLinkedTokenSource(first.Token, second.Token); } private CallCancel(){ // 此时同时取消两个 Token linkedCancelSource.Cancel(); linkedCancelSource.Dispose(); // 每个 CancellationTokenSource 只能使用一次，所以需要重新创建 LinkCancelSource(); } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unitask/","title":"UniTask 学习笔记"},{"content":"Cinemachine 的更新 3.0 Cinemachin e的基本介绍 介绍 - CSDN\nCinemachine Brain Update 方式 描述 FixedUpdate LateUpdate SmartUpdate 比较 FixedUpdate 和 LateUpdate 哪个更新的次数更多，就用哪个，会有一些消耗 ManualUpdate 手动在脚本里调用，目前demo里的用法，在lateupdate里调用，再同步一些物体的旋转，防止抖动 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/cinemachine/","title":"Unity Cinemachine 3.0"},{"content":"Inspector 扩展 将 Inspector 扩展应用到子类 [CustomEditor(typeof(BaseGun), true)] public class CustomInspector : Editor{ } 重写 OnInspectorGUI (IMGUI框架) 添加默认显示的 Attribute base.OnInspectorGUI(); 重写 CreateInspectorGUI (UIToolkit框架) 添加默认显示的 Attribute var root = new VisualElement(); root.Add(new IMGUIContainer(OnInspectorGUI)); ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unityinspector%E6%89%A9%E5%B1%95/","title":"Unity Inspector 拓展笔记"},{"content":"PingPong PingPong 返回一个在零和长度之间递增和递减的值。它遵循三角波公式，其中底部设置为零，峰值设置为长度。\nPingPong 要求值 t 是自增量值。例如，Time.time和Time.unscaledTime。\nvar amplitude = 2; // 振幅 var period = 2; // 一往復する周期（秒） var phase = 0.25f; // 位相（１で１周分） // 位相を考慮した時間補正 var t = 4 * amplitude * (Time.time / period + phase + 0.25f); // 指定された振幅、周期、位相のPingPong var value = Mathf.PingPong(t, 2 * amplitude) - amplitude; ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unitymathf/","title":"Unity Mathf 笔记"},{"content":"Interactor Select Action Trigger Name Description State Unity将考虑在按下按钮时激活输入。用户可以在交互成为可能之前保持按钮，并且仍然在交互成为可能时触发交互。（一只手交互时，另一只手不能获取交互物） StateChange Unity将考虑仅在按下按钮的框架上激活输入，如果成功，则保持接合，直到释放输入。当交互可能触发交互时，用户必须按下按钮。如果他们在交互成为可能之前开始按下按钮，他们将不会触发交互。（一只手交互时，另一只手可以获取物品交互权） Sticky 交互在输入被按压的帧上开始，并且保持接合直到输入被第二次释放。 Toggle 交互在输入被按压的帧上开始，并且保持接合直到输入被第二次按压。 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/xr-interactiontoolkit/","title":"Unity XR Interaction 笔记"},{"content":"像 Alyx 一样抓取物体 Source Video: https://www.youtube.com/watch?v=WU23Uj1oeh8\n基于 Unity XR Interaction Toolkit 2.6.3\nRay Interactor 在 Interaction Layer Mask 设置好交互层级为 Interactable Default\nAnchor Control 选项可选\nGrablale Object 可以抓取的物体需要有 mesh collider 组件\n注意 Interaction Layer Mask 以及 Movement Type 的设置\nXR Alyx Grab Interactable 该脚本继承于 XRGrabInteractable\n功能简介：\n对准可抓取的物体时显示射线，物体会显示描边（可选显示一层覆盖颜色） 按住抓取按键时选中物体 选中物体后将手柄向上提起，物体会向手部位置飞去 ❗飞来的物体需要再次按抓取键才能抓在手上\n下面是脚本代码\nusing System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.XR.Interaction.Toolkit; public class XRAlyxGrabInteractable : XRGrabInteractable { [Tooltip(\u0026#34;跳跃的速度阈值\u0026#34;)] public float velocityThreshold = 2f; [Tooltip(\u0026#34;跳跃时的角度\u0026#34;)] public float jumpAngleInDegree = 60f; private XRRayInteractor rayInteractor; private Vector3 previousPos; private Rigidbody rb; private bool canJump = true; protected override void Awake() { base.Awake(); rb = GetComponent\u0026lt;Rigidbody\u0026gt;(); } private void Update() { if (isSelected \u0026amp;\u0026amp; canJump \u0026amp;\u0026amp; firstInteractorSelecting is XRRayInteractor) { // 当物体被抓住时，计算速度是否超过阈值，超过则执行跳跃 Vector3 velocity = (rayInteractor.transform.position - previousPos) / Time.deltaTime; previousPos = rayInteractor.transform.position; if (velocity.magnitude \u0026gt; velocityThreshold) { // 脱离抓取 Drop(); // 计算跳跃初速度 rb.velocity = ComputeVelocity(transform.position, rayInteractor.transform.position, jumpAngleInDegree, Physics.gravity.y); canJump = false; } } } /// \u0026lt;summary\u0026gt; /// 基于重力计算弹道轨迹，计算从自身跳跃到指定地点的跳跃速度 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;selfPos\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;targetPos\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;jumpAngle\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;gravity\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public static Vector3 ComputeVelocity(Vector3 selfPos, Vector3 targetPos, float jumpAngle, float gravity) { Vector3 diff = targetPos - selfPos; Vector3 diffXZ = new(diff.x, 0, diff.z); float diffXZLength = diffXZ.magnitude; float diffYLength = diff.y; float angleInRadian = Mathf.Clamp(diff.normalized.y * 90, jumpAngle, 90) * Mathf.Deg2Rad; float jumpSpeed = Mathf.Sqrt(-gravity * Mathf.Pow(diffXZLength, 2) / (2 * Mathf.Cos(angleInRadian) * Mathf.Cos(angleInRadian) * (diffXZ.magnitude * Mathf.Tan(angleInRadian) - diffYLength))); Vector3 jumpVelocityVector = jumpSpeed * Mathf.Cos(angleInRadian) * diffXZ.normalized + jumpSpeed * Mathf.Sin(angleInRadian) * Vector3.up; return jumpVelocityVector; } protected override void OnSelectEntered(SelectEnterEventArgs args) { // 控制器检测 只响应射线交互器 if (args.interactableObject is XRRayInteractor) { trackPosition = false; trackRotation = false; throwOnDetach = false; rayInteractor = (XRRayInteractor)args.interactorObject; previousPos = rayInteractor.transform.position; canJump = true; } else { trackPosition = true; trackRotation = true; throwOnDetach = true; } base.OnSelectEntered(args); } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unityxr-alxygrab/","title":"Unity XR 像 Alyx 一样抓取物体"},{"content":"继承 MonoBehaviour 跨场景调用 using UnityEngine; namespace UnityUtils { /// \u0026lt;summary\u0026gt; /// 跨场景使用的Mono单例基类 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;\u0026lt;/typeparam\u0026gt; public class PersistentSingleton\u0026lt;T\u0026gt; : MonoBehaviour where T : Component { public bool AutoUnparentOnAwake = true; protected static T instance; public static bool HasInstance =\u0026gt; instance != null; public static T TryGetInstance() =\u0026gt; HasInstance ? instance : null; public static T Instance { get { if (instance == null) { instance = FindAnyObjectByType\u0026lt;T\u0026gt;(); if (instance == null) { var go = new GameObject(typeof(T).Name + \u0026#34; Auto-Generated\u0026#34;); instance = go.AddComponent\u0026lt;T\u0026gt;(); } } return instance; } } /// \u0026lt;summary\u0026gt; /// Make sure to call base.Awake() in override if you need awake. /// \u0026lt;/summary\u0026gt; protected virtual void Awake() { InitializeSingleton(); } protected virtual void InitializeSingleton() { if (!Application.isPlaying) return; if (AutoUnparentOnAwake) { transform.SetParent(null); } if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } else { if (instance != this) { Destroy(gameObject); } } } } } 同场景调用 using System.Collections; using System.Collections.Generic; using UnityEngine; /// \u0026lt;summary\u0026gt; /// 单例模式基类 同场景内使用 /// \u0026lt;/summary\u0026gt; /// \u0026lt;typeparam name=\u0026#34;T\u0026#34;\u0026gt;子类\u0026lt;/typeparam\u0026gt; \u0026lt;summary\u0026gt; public class SameSceneSingleMono\u0026lt;T\u0026gt; : MonoBehaviour where T : SameSceneSingleMono\u0026lt;T\u0026gt; { public static T Instance; protected virtual void Awake() { if (Instance != null) Debug.LogError(this + \u0026#34;出现多个单例!\u0026#34;); Instance = (T)this; } protected void OnDestroy() { Destroy(); } public void Destroy() { Instance = null; } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%8D%95%E4%BE%8B/","title":"Unity 单例"},{"content":"热更新 HybridCLR + Addressable 环境确认 1.1 Unity 1.1.1 使用的Unity版本为2022.3.13f1\n1.1.2 安装UnityComponent添加对IL2CPP的支持\n笔记：https://blog.csdn.net/Chenxin_37/article/details/136747145\n1.2 Visual Studio 1.2.1 安装“使用Unity的游戏开发”和“使用C++的游戏开发”套件\n1.2.2 安装Window10-SDK最新版即可\n框架搭建 2.1 创建新项目 2.2 安装HybridCLR\n安装详看文档\n文档主页：https://hybridclr.doc.code-philosophy.com/docs/beginner/quickstart\n国内Git地址：https://gitee.com/focus-creative-games/hybridclr_unity.git\n国外Git地址：https://github.com/focus-creative-games/hybridclr_unity.git\n2.3 创建Asset/HotUpdate文件夹\n2.4 在HotUpdate文件夹创建HotUpdate的程序集（Assembly Definition）\n2.5 在HotUpdate文件夹任意创建一个脚本\n2.6 在Visual Studio重载项目，此时的解决方案资源管理器应该显示两个程序集，如图\n2.7 选择Unity的上方菜单项HybridCLR/Installer\u0026hellip;\n选择Install（安装成功后控制台会打印成功的信息，以及绿框位置显示为True）\n2.8 选择Unity的上方菜单项HybridCLR/Settings\u0026hellip;\n2.9 在热更新Assembly Definition中添加在HotUpdate文件夹中的程序集\n如果没有显示HybridCLR Settings，重启Unity\n2.10 选择Unity的上方菜单项Edit/Project Settings\u0026hellip;\n在左侧选择Player\n在下方展开Other Settings\n2.11 按照图中选项修改\n2.12 选择Unity的上方菜单项HybridCLR/Generate/All\n2.13 将{proj}/HybridCLRData/HotUpdateDlls/StandaloneWindows64(MacOS下为StandaloneMacXxx)目录下的HotUpdate.dll重命名为HotUpdate.dll.bytes，将其复制到Asset/HotUpdate/Dlls内（无则新建）\n（可选：对项目进行一次打包）\n2.14 在HotUpdate文件夹下的所有脚本发生任何变更后，都需要在Unity的上方菜单项选择HybridCLR/CompileDll/ActiveBuildTarget\n安装Adressable 3.1 打开Package Manager窗口\n选择Package：Unity Registry\n搜索Addressable\n点击Install安装\n3.2 选择Unity的上方菜单项Window/Asset Management/Addressable/Groups\n选择Generate\u0026hellip;\n选择Profile：Default\n选择Manage Profiles\n3.3 修改设置\n选择Remote 为 Custom\n将Remote.LoadPath修改为自己的远程或本地的http资源服务器，路径内文件为本地的{project}/ServerData/[BuildTarget]\n3.4 点击Addressables Groups窗口的New\n创建一个新的组并命名为HotUpdateDll\n选择组，在右侧Inspector窗口修改Build \u0026amp; Load Paths 为 Remote\n3.5 在Project窗口找到AddressableAssetSettings\n在Inspector窗口勾选Build Remote Catalog\n3.6 选择Asset/HotUpdate/Dlls/HotUpdate.dll\n（此时该文件在文件管理器中的后缀应为.bytes）\n将其拖入Addressables Groups窗口的HotUpdateDll组内（打上标签Dll）\n3.7 选择Play Mode Script里的第三项Use Exiting Build（Window）\n3.8 点击Player Mode\u0026hellip; 左侧的Build，选择New Build/Defalut Build Script\n此时在{Project}/ServerData下会有文件夹为StandardWindow64文件夹\n此文件夹内文件需与资源服务器内容同步\n脚本热更新操作步骤 4.1 在HotUpdate文件夹下的所有脚本发生任何变更后，都需要在Unity的上方菜单项选择HybridCLR/CompileDll/ActiveBuildTarget\n4.2 在Addressables Groups窗口选择Build/New Build/Defalut Build Script\n4.3 同步ServerData文件夹内的文件至资源服务器\n4.4 运行客户端下载\n在HotUpdate文件下的脚本注意 5.1 在引用其他命名空间时，在客户端有可能会出现Script Missing错误\n因此需要选择HotUpdate文件夹里的HotUpdate程序集\n在Inspector勾选Allow \u0026lsquo;unsafe\u0026rsquo; Code\n在Assembly Definition Reference添加引用的命名空间程序集\n5.2 在Assets/StreamingAssets文件夹放置对应所需的Dll文件\n并在客户端的资源检查脚本第一时间读取\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E7%83%AD%E6%9B%B4%E6%96%B0%E6%A8%A1%E5%9D%97/","title":"Unity 的热更新"},{"content":"判断Animator中是否存在动画 Unity中的animator是以哈希值存储动画状态的索引，先通过动画片段名字字符串获取哈希值，再用HasState这个API获取存在状态\n再通过animator.CrossFadeInFixedTime(animationName, time);过渡动画\nstring animationName; int stateID = Animator.StringToHash(animationName) bool hasAnimation = animator.HasState(layerIndex, stateID) ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/animation-api/","title":"Unity 动画 API"},{"content":"基于 Unity.InputSystem 和下推状态机的输入系统解决方案 原贴地址：王子饼干 - 知乎\nUnity.InputStstem的优点 InputSystem的优点在于它能够便捷的识别不同设备的按键输入，并使同一动作对不同设备的输入做出响应。\n原生提供了开启和阻断输入的方法，以及切换绑定按键的方式。\n代理控制器 创建 DRockBridge 作为一个代理控制器来接收 InputSystem 的控制，然后这个代理对象再去控制上层游戏对象。\n这样的 InputSystem 只需要与 Bridge 交流，游戏对象也只需要从 Bridge 接受输入。\n同时也只需要在 Bridge 中切换绑定按键，而不影响游戏对象。\n创建通用状态机 为什么要用状态机来管理所有控制对象，简单来说，大部分的时候只有一个控制器是有效的，而这个控制器被激活时也往往伴随着它要控制的 GameObject 的激活。比如打开主菜单时，代码需要激活主菜单，与此同时关闭角色控制器并打开 UI 控制器。\n在主菜单的某个选项选中时，有可能会打开一个子菜单，也有可能会进入一个特殊的模式，比如有的游戏存在建造模式，或者打开了什么商店等。假设我们把打开一个子菜单也视为一个游戏 API 功能的话，肯定要为其单独增加一个函数。首先肯定要关闭主菜单，其次如果我们打开的不是子菜单，而是某个特殊的模式，还要启动对应的控制器，并关闭现有的控制器。\n所以为了解决上述问题，可以将控制器和被控制对象视为一个整体，或者一整个状态。这样启动控制器的同时就启动被控制对象。这样会使得控制器的阻断更加紧凑，或者说，不再需要手动管理。\n这样做更好的一点是，此后我们可以将游戏的控制逻辑视为多个状态。这样只要定义好数个状态对象，此后管理所有的状态对象即可。不需要再在单独的函数中设置输入是否关闭或者开启。\n下推状态机 下推状态机有一个 buffer 缓存区和一个 stack 栈区。在 buffer 缓存区的是当前状态，该状态决定了接收 Bridge 中的什么输入，阻断什么输入。\n当有新状态推入 Buffer 缓存区时，先前的状态就推入 Stack 栈区中。\n以此类推当新状态推入时。\n当 Buffer 缓存区的状态退出时，就从 Stack 栈区中推出上一个状态，可以解决主菜单与子菜单等的衔接。\n并且可以在状态切换时添加更多的细致的动作逻辑。\n例如：\n当状态从外界被推入临时位时，执行 OnEnter 函数\n当状态从临时位被移除时，执行 OnExit 函数\n当状态从临时位被压入栈区时，执行 OnPause 函数\n当状态从栈区被回滚到临时位时，执行 OnResume 函数\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/input/","title":"Unity 基于下推状态机的输入系统解决方案"},{"content":"不支持 Unity 序列化的字段 静态字段 static fields\n只读字段 readonly fields\n常量 const fields\n未带有 [field: SerializeFied] 特性的属性\n支持 Unity 序列化的字段 公开的 非静态 非只读 非常量 字段\npublic non-static non-readonly non-const fields\n带有 [SerialzeFied] 的非静态 非只读 非常量 字段\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unity%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Unity 序列化笔记"},{"content":"3D Demo 特点 Reliable FPS System 可靠的fps系统\nSmooth Control And Responsive 流畅的控制和灵敏的反应\nFullbody System 全身渲染和运动系统\n功能模块 UI框架（TODO） 基于Dotween进行UI动效制作\n存档系统✓ 利用双列表建立可序列化字典，进行游戏数据记录，存档时转为JSON文件实现数据持久化保存和读取\n库存系统✓ 基于ScriptableObject的物品数据库\n交互操作✓ Camera✓ 使用Unity提供的Cinemachine进行相机管理，实现第一人称视角与第三人称视角的相机跟随\n角色控制系统（Doing） 基于Unity.InputSystem和下推状态机的输入系统解决方案\n角色运动状态机\n角色胶囊体运动模拟计算使用KCC插件管理\n多载具控制\n音效系统（TODO） Wwise\n资源管理与热更新✓ 使用AssetsAddressable进行远程资源加载，使用HybridCLR+Addressables实现热更新\n泛型对象池✓ 基于纯C#类的泛型对象池，可扩展实现继承MonoBehavior的对象池，从而减少实例化次数，优化游戏性能\n角色动画 第三人称动画与角色状态匹配\n行为树 AI 寻路算法 ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/demo%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BB%BB%E5%8A%A1%E8%A1%A8/","title":"Unity 学习 Demo 的模块任务表"},{"content":"Code 继承于unityobject的类的判空，unity对于 == 进行了重构，会带来GC消耗，因此尽量不要在update处进行判空\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/unity%E4%BC%98%E5%8C%96%E6%B3%A8%E6%84%8F/","title":"Unity 优化笔记"},{"content":"行为树 示例 僵尸 AI 特点 僵尸 AI 能根据自身情况（生命值，中枪与否）和外部条件（周围是否存在玩家），采取合理的行动。\nAI基础 基本行为操控（靠近，远离，追逐，逃避\u0026hellip;）\n寻路能力（从游戏场景中一个位置移动到另一个位置，最短路径）\n感知能力（自身状态如血量，听觉和视觉等感知能力）\n自主决策能力（根据自身状态和外部条件作出合理的反应）\n基本行为操控 基本运动：行走，奔跑\n高级运动：跳跃，攀爬，躲避\n攻击：近身攻击，远程攻击，破坏障碍物\n寻路 使用 Unity 的 Navigation 导航系统，实现自动寻路。\n感知能力 视觉 能够感知到玩家是否在视野范围内，视野内是否有障碍物\n听觉 能够感知到玩家的脚步声，枪声，环境噪声（如爆炸，器械启动）\n受击反馈 在受到伤害时（如玩家攻击，爆炸等），会有受击动作，同时能感知到伤害来源\n自主决策能力 实现方式有：有限状态机，行为树，行为树与有限状态机结合\n有限状态机（Finite State Machine） 稍微复杂的僵尸逻辑\n僵尸的感知范围内没有玩家时-\u0026gt;僵尸随机游荡\n僵尸受到攻击-\u0026gt;僵尸向开枪时所在的方向进行搜索\n僵尸感知到玩家-\u0026gt;僵尸追踪玩家\n玩家进入僵尸攻击范围-\u0026gt;僵尸攻击玩家\n玩家死亡或脱离僵尸感知范围-\u0026gt;僵尸回到随机游荡\n僵尸生命值变为0-\u0026gt;僵尸进入死亡状态\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%9F%BA%E4%BA%8E%E8%A1%8C%E4%B8%BA%E6%A0%91%E7%9A%84ai/","title":"基于行为树的 AI"},{"content":"类鸟群行为（集群行为） 有时在游戏中为了添加沉浸感，会在深海环境，自然开放环境加入鸟群，鱼群。如何控制鸟群的运动，使其符合现实，不会突兀，且性能友好是该部分讨论的内容。\n参考视频：https://www.youtube.com/watch?v=bqtqltqcQhw\n国内视频翻译：https://www.bilibili.com/video/BV1VJ411y7wE/\n鸟群中每只鸟有以下三个规则：\n偏离附近的其他鸟（分离）\n迎合附近鸟群，转向同一方向（对齐）\n会自行向附近的鸟群中心飞去（凝聚）\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ai%E6%A8%A1%E5%9D%97-%E9%9B%86%E7%BE%A4%E8%A1%8C%E4%B8%BA/","title":"集群行为 AI子模块"},{"content":"模块化角色控制状态机 在我的 3D Demo 中，我需要控制一个具有高可扩展性的角色控制器，因此对其开始探究\n由于对引擎代码的理解不深，也暂时没有什么兴趣研究，因此选择了基于 KCC 角色控制器框架进行开发\n文章引用：\n有限状态机的实现与使用 Kinematic Character Controller CharacterControl 继承 MonoBehaviour, ICharacterController\n角色的控制器，也是这个模块最重要的一个组件\n担任 MVC 模式中 Controller 角色\n所有的状态模块在实例化后都需要在 CreateFSM 方法中加入 FSM 中才能被角色启用\nprivate void CreateFSM() { // 在创建状态机时输入第一个状态 FSM = new(idle, this); FSM.AddState(fly); FSM.AddState(inAir); FSM.AddState(crouching); } IMovementState 继承 ICharacterController\n状态模块的基类，所有自定义的状态模块都需要继承该类\n在 HandleStateChange(ref PlayerCharacterInput inputs) 方法中实现状态变换的操作\nGravityConfig 用于设定角色的重力\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/charactercontrol/","title":"库存管理系统"},{"content":"库存管理模块 Inventory System 功能实现 编辑器功能（Editor） 列表显示物品库里所有物品 新增 Item 可以自动赋予 ID 允许编辑 ID 增加 Tip 提示 增加 Item 搜索功能 增加从 Excel 导入导出功能 增加从 JSON 导入导出功能 Item 可以使用 ItemType 进行分类显示 游戏内界面（UI） 塔科夫式背包\n背包固定格子，每个物品需要占用不同的格子大小 支持拖拽移动背包物品 支持给可使用物品设置使用热键 显示快捷物品栏\n允许在快捷物品栏滚轮切换物品选择 动态调整快捷物品栏容量 背包界面\n允许鼠标拖拽物品 组合键获取一半的物品 核心代码（Code） ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"库存管理系统"},{"content":"随机洗牌 Knuth-Durstenfeld Shuffle 算法时间复杂度 O(n)\n算法空间复杂度 O(1)\n假设有这样一个数组 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们使用 Knuth-Shuffle 算法将数据打乱。\n基本流程是这样的，从最后一个数开始，往前遍历，每一次，从当前数和第 1 个数之间，随机选择一个数，与当前数字进行交换（这里的随机选择就直接使用程序语言中的 Random 随机一个索引即可）。\n例如上面的数组，第一次循环，当前数字为 10，我们从 1~10 之间，随机选择一个数，与 10 交换，这样第 9 个索引位就算洗完了，接下来就是第 8 个索引位，也就是数字为 9，我们从第 1 个索引位与第 8 个索引位之间，选择一个数，第 9 交换，这样第 8 个索引位也就洗完了\u0026hellip;\n这个算法之所以公平，是因为保证了每一个元素出现在每一个位置上的概率，都是一样的。\nusing System; using System.Collections.Generic; class Program { static void Main(string[] args) { List\u0026lt;int\u0026gt; songList = new List\u0026lt;int\u0026gt;(); songList.Add(1); songList.Add(2); songList.Add(3); songList.Add(4); songList.Add(5); songList.Add(6); songList.Add(7); songList.Add(8); songList.Add(9); songList.Add(10); Random rand = new Random(); // 开始洗牌算法 int last = songList.Count - 1; for (int i = last; i \u0026gt;= 0; --i) { // 从当0~当前索引位之间，选择一个数 int selection = rand.Next(i + 1); // 索引位对应的数据交换 int temp = songList[i]; songList[i] = songList[selection]; songList[selection] = temp; } // 打印洗牌后的List for (int i = 0; i \u0026lt; songList.Count; ++i) { Console.Write(songList[i] + \u0026#34; \u0026#34;); } } } ","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/%E6%B4%97%E7%89%8C/","title":"随机洗牌算法"},{"content":"动态避障算法 RVO RVO是基于VO算法的优化\n源码作者Github：https://github.com/snape\nRVO仓库：https://gamma.cs.unc.edu/RVO2/\nUnity实现例子：https://github.com/warmtrue/RVO2-Unity/tree/master\nRVO算法的优化：\nORCA**（Optimal Reciprocal Collision Avoidance）**\nORCA中文文档：https://blog.csdn.net/u012740992/article/details/89397714\n结合A*寻路与ORCA的项目：https://arongranberg.com/astar/front\n文章：\nMotion Planning in Dynamic Environments Using Velocity Obstacles\nhttps://ieeexplore.ieee.org/document/292038\nReciprocal Velocity Obstacles for real-time multi-agent navigation\nhttps://www.academia.edu/93509158/Reciprocal_Velocity_Obstacles_for_real_time_multi_agent_navigation\n","date":"0001-01-01T00:00:00Z","permalink":"http://localhost:1313/post/ai%E6%A8%A1%E5%9D%97-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/","title":"寻路算法"}]